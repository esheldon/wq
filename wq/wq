#!/usr/bin/env python
"""
    %prog [options] command [command options]

Basic command modes are the following.  There are additional
options for each command

    sub:        Submit a job.
    ls:         Print the job listing
    stat:       Get the status of the cluster/queue.
    rm:         Remove a job.
    refresh:    Force a refresh of the job queue.

To get help on each command, use -h, for example
    %prog sub -h
    %prog rm -h

"""

import socket
import sys
import json
import os
import signal 
import wq

from optparse import OptionParser

# need to move this into server.py and require a real installation
_COMMANDS = ['serve','sub','ls','stat','rm','refresh']

pars={'host':'',      # Symbolic name meaning all available interfaces
      'port':wq.DEFAULT_PORT ,
      'max_buffsize':wq.MAX_BUFFSIZE}


class ServerWrapper:
    """
    usage: wq serve cluster_def_file
    """
    def __init__(self, args):
        import wq
        parser=OptionParser(ServerWrapper.__doc__)
        if len(args) < 1:
            parser.print_help()
            sys.exit(1)

        self.srv = wq.server.Server(args[0], port=pars['port'])
    def execute(self):
        self.srv.run()

class Lister(dict):
    """
    usage: wq ls [options]

    print the jobs in the queue to stdout.  If -f/--full is sent,
    the full command line is displayed and the full host list is displayed.
    Normally, only the first part of the command is shown, and only the
    number of hosts is shown.
    """

    def __init__(self, args):
        #Command.__init__(self, args)
        self._process_args(args)

    def _process_args(self, args):
        parser=OptionParser(Lister.__doc__)
        parser.add_option("-u", "--user", default=None, 
                          help="Only list jobs for the user.  can be a comma separated list")
        parser.add_option("-f", "--full", action='store_true',
                          help="Give a more detailed listing")

        options, args = parser.parse_args(args)
        self.user = options.user
        self.full = options.full

        if self.user is not None:
            self.user = self.user.split(',')

    def execute(self):
        message={}
        message['command'] = 'ls'

        resp = send_message(message)


        if self.full:
            hname='hosts'
        else:
            hname='nhosts'
        names = ['pid','user','status','ncores',hname,'command']

        lens={}
        for k in names:
            lens[k] = len(k)

        nrun=0
        nwait=0
        lines = []
        for r in resp['response']:

            if (self.user is None) or (r['user'] in self.user):
                if r['status'] == 'run':
                    nrun+=1
                else:
                    nwait+=1

                this={}
                this['pid'] = r['pid']
                this['user'] = r['user']
                this['status'] = self._get_status(r)
                this['ncores'] = self._get_ncores(r)
                this['command'] = self._get_command(r)

                if self.full:
                    this['hosts'] = self._get_hosts(r)
                else:
                    this['nhosts'] = self._get_nhosts(r)
                
                for k in this:
                    lens[k] = max(lens[k], len(('%s' % this[k])))
                
                lines.append(this)

        fmt = []
        for k in names:
            fmt.append('%('+k+')-'+str(lens[k])+'s')
        fmt = ' '.join(fmt)
        fmt = ' '+fmt


        # this is the header for each column
        if len(lines) > 0:
            print fmt % {'pid':'Pid','user':'User',
                         'status':'Status', 'ncores':'Ncores',hname:hname,'command':'Command'}
        for l in lines:
            print fmt % l

        stats='Running: %s Waiting: %s' % (nrun,nwait)
        if self.user is not None:
            print ' User: %s Jobs: %s' % (','.join(self.user),stats)
        else:
            print ' Jobs: %s' % stats
                
    def _get_ncores(self, r):
        if r['status'] == 'run':
            return len(r['hosts'])
        else:
            return '-'

    def _get_hosts(self, r):
        if r['status'] != 'run':
            return '-'

        if not r['hosts']:
            return '-'
        else:
            hd={}
            for host in r['hosts']:
                hd[host] = host
            hosts = list(hd.keys())
            hosts.sort()
            return ','.join(hosts)

    def _get_nhosts(self, r):
        if r['status'] == 'run':
            hd={}
            for host in r['hosts']:
                hd[host] = host
            return len(hd)
        else:
            return '-'

    def _get_status(self, r):
        if self.full:
            if r['status'] == 'run':
                return 'running'
            else:
                return r['reason']
        else:
            if r['status'] == 'run':
                return 'R'
            else:
                return 'W'

    def _get_command(self, r):
        if self.full:
            return r['commandline']
        else:
            return r['commandline'].split()[0]

class Stats(dict):
    """
    usage: wq stat

    print the status of the queue and compute cluster
    """

    def __init__(self, args):
        parser=OptionParser(Stats.__doc__)
        options, args = parser.parse_args(args)

    def execute(self):
        message={}
        message['command'] = 'stat'

        resp = send_message(message)

        print 'cluster status: make this nicer'
        print resp['response']

class Refresher(dict):
    """
    usage: wq refresh

    Request that the server refresh it's job list
    """

    def __init__(self, args):
        parser=OptionParser(Refresher.__doc__)
        options, args = parser.parse_args(args)

    def execute(self):
        message={}
        message['command'] = 'refresh'

        resp = send_message(message)

class Remover(dict):
    """
    usage: wq rm pid

    Request that the server remove the specified job
    """

    def __init__(self, args):
        parser=OptionParser(Remover.__doc__)
        options, args = parser.parse_args(args)
        if len(args) < 1:
            parser.print_help()
            sys.exit(1)

        self.pid = int(args[0])

    def execute(self):
        message={}
        message['command'] = 'rm'
        message['pid'] = self.pid

        resp = send_message(message)

        print resp



class Submitter(dict):
    """
    usage: wq sub [options] [args]

    two basic modes:
        1) 
            wq sub -r require job_file
        require will over-ride requirements in the job file.

        2)
            wq sub -r require -c command
        The command is just a string.  You probably want to
        double quote it.
    """
    def __init__(self, args):
        #Command.__init__(self, args)
        self._process_args(args)

    def _process_args(self, args):
        parser=OptionParser(Submitter.__doc__)
        parser.add_option("-r", "--require", default=None, help="optional requirements for job")
        parser.add_option("-c", "--command", default=None, help="The command to run as a string")

        options, args = parser.parse_args(args)

        self['require_arg'] = options.require
        if len(args) > 0:
            # a job file was sent
            job_file = args[0]
            self._process_job_file(job_file)
        else:
            if options.command is None:
                parser.print_help()
                sys.exit(1)
            command = options.command
            self._process_command_string(command)

    def _process_job_file(self, fname):
        import yaml

        self['require'] = yaml.load(open(fname))
        if 'command' not in self['require']:
            raise ValueError("no command found in job file")
        self['commandline'] = self['require']['command']

        # don't need this in the requirements
        del self['require']['command']
        

    def _process_command_string(self, command):
        """
        The command is determined by an argument.  Requirements are only
        specified by -r/--require now
        """
        require = self._process_require_arg()

        self['require'] = require
        self['commandline'] = command

    def _process_require_arg(self):
        import yaml
        import re

        req={}
        if self['require_arg'] is None:
            return req

        # convert semicolon to newline
        r = self['require_arg']
        r = re.sub(';\s*', '\n', r)
        # make sure there is a space between : and valule
        r = r.replace(':',': ')
        
        req = yaml.load(r)

        """
        reqlist = self['require_arg'].split(':')
        for r in reqlist:
            rs = r.split('=')
            if len(rs) == 2:
                key = rs[0]
                try:
                    val = eval(rs[1])
                except:
                    val = rs[1]

                req[key] = val
            else:
                raise ValueError("mis-formatted requirements arg: %s'" % r)
        """
        return req

    def print_job_info(self):
        print '------------'
        print 'Job info:\n'
        print 'command line:',self['commandline']
        for k in self['require']:
            print '%s: %s' % (k,self['require'][k])
        print '------------'

    def receive_signal(self,a,b):
        pass

    def execute(self):
        message = {}
        message['command'] = 'sub'
        message['pid'] = os.getpid()
        message['user'] = os.environ['USER']
        message['require'] = self['require']
        message['commandline'] = self['commandline']
        #self.print_job_info()

        sres = send_message(message)

        if sres['response'] == 'wait':
            # wait until we can go
            print "waiting:",sres['reason']
            signal.signal(signal.SIGUSR1, self.receive_signal)
            signal.pause()
            message['command']='gethosts'
            sres=send_message(message)

        ## time to run

        ## if hostfile specified need to create one

    
        ### Now execute
        hosts=sres['hosts']
        if 'hostfile' in self['require']:
            f=open(self['require']['hostfile'],'w')
            for h in hosts:
                f.write(h+'\n')
            f.close()


        target=hosts[0]
        pwd =os.getcwd()
        command=self['commandline']
        ## here we execute
        print "executing with pid:",message['pid']
        os.system ('ssh -t '+target+'  "cd '+pwd+'; '+command+' "')
        
        print "done"
        ### now we notify done.

        message['command']='notify'
        message['notification']='done'
        sres = send_message(message)
        print sres
                             



def send_message(message):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((pars['host'], pars['port']))

    try:
        sock.send(json.dumps(message))

        data = sock.recv(pars['max_buffsize'])

        #print 'data from server:',data
        rdict = json.loads(data)
        sock.close()

        if 'error' in rdict:
            raise RuntimeError("Error reported by server: %s" % rdict['error'])

        if 'response' not in rdict:
            raise RuntimeError("Internal error. Expected a response and got screwed.")

    except RuntimeError as e:
        sock.close()
        print e
        sys.exit(1)
    finally:
        sock.close()

    return rdict


def get_command_obj(args):
    if args[0] == 'sub':
        return Submitter(args[1:])
    elif args[0] == 'ls':
        return Lister(args[1:])
    elif args[0] == 'stat':
        return Stats(args[1:])
    elif args[0] == 'rm':
        return Remover(args[1:])
    elif args[0] == 'refresh':
        return Refresher(args[1:])
    elif args[0] == 'serve':
        return ServerWrapper(args[1:])
    else:
        return None

def main():

    parser=OptionParser(__doc__)
    # this won't be used in the usual way
    parser.add_option("-p", "--port", default=None, help="port for socket")

    args = sys.argv[1:]
    if len(args) == 0:
        parser.print_help()
        sys.exit(1)

    if args[0] == '-h':
        parser.print_help()
        sys.exit(1)

    if args[0] == '-p':
        del args[0]
        try:
            pars['port'] = int(args[0])
        except:
            print 'Could not extract port from input: %s' % args[1]
            sys.exit(1)
        del args[0]

    cmd = args[0]
    cmd_obj = get_command_obj(args)
    if cmd_obj is None:
        parser.print_help()
        sys.exit(1)

    try:
        cmd_obj.execute()
    except KeyboardInterrupt:
        pass

if __name__=="__main__":
    main()
