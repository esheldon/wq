#!/usr/bin/env python
"""
    %prog [options] command [command options]

Basic command modes are the following.  There are additional
options for each command

    sub:        Submit a job.
    ls:         Print the job listing
    stat:       Get the status of the cluster/queue.
    rm:         Remove a job or all jobs for a user.
    refresh:    Force a refresh of the job queue.
    serve:      Run a server.

To get help on each command, use -h, for example
    %prog sub -h
    %prog rm -h

"""

import socket
import sys
import json
import os
import signal 
import wq
import time
import subprocess

from optparse import OptionParser

# need to move this into server.py and require a real installation
_COMMANDS = ['serve','sub','ls','stat','rm','refresh']

pars={'host':'',      # Symbolic name meaning all available interfaces
      'port':wq.DEFAULT_PORT ,
      'max_buffsize':wq.MAX_BUFFSIZE}

# note this is different from the timeout for the server.
SOCK_TIMEOUT = 45.0

class ServerWrapper:
    """
    usage: wq serve cluster_def_file

    The def file is one line per node

        hostname ncores mem groups

    The groups are an optional comma separate list.
    """
    def __init__(self, args):
        import wq
        parser=OptionParser(ServerWrapper.__doc__)
        if len(args) < 1:
            parser.print_help()
            sys.exit(1)

        if args[0] == '-h':
            parser.print_help()
            sys.exit(1)

        self.srv = wq.server.Server(args[0], port=pars['port'])
    def execute(self):
        self.srv.run()

class Lister(dict):
    """
    usage: wq ls [options]

    print the jobs in the queue to stdout.  If -f/--full is sent, the full
    command line is displayed and the full host list is displayed.  Normally,
    only the first part of the command is shown, and only the number of hosts
    is shown.  If -u/--user is sent, the listing is restricted to that
    user/users.

    """

    def __init__(self, args):
        #Command.__init__(self, args)
        self._process_args(args)

    def _process_args(self, args):
        parser=OptionParser(Lister.__doc__)
        parser.add_option("-u", "--user", default=None, 
                          help="Only list jobs for the user.  can be a comma separated list")
        parser.add_option("-f", "--full", action='store_true',
                          help="Give a more detailed listing")

        options, args = parser.parse_args(args)
        self.user = options.user
        self.full = options.full

        if self.user is not None:
            self.user = self.user.split(',')

    def execute(self):
        message={}
        message['command'] = 'ls'
        resp = send_message(message)


        if self.full:
            hname='hosts'
        else:
            hname='nhosts'
        names = ['pid','user','status','priority','ncores',hname,'command','time_sub','time_run']

        lens={}
        for k in names:
            lens[k] = len(k)

        nrun=0
        nwait=0
        lines = []
        timenow = time.time()
        for r in resp['response']:

            if (self.user is None) or (r['user'] in self.user):
                if r['status'] == 'run':
                    nrun+=1
                else:
                    nwait+=1

                this={}
                this['pid'] = r['pid']
                this['user'] = r['user']
                this['priority'] = r['priority']
                this['status'] = self._get_status(r)
                this['ncores'] = self._get_ncores(r)
                this['command'] = self._get_command(r)
                this['time_sub'] = self._get_time_in(r,timenow)
                this['time_run'] = self._get_time_run(r,timenow)

                if self.full:
                    this['hosts'] = self._get_hosts(r)
                else:
                    this['nhosts'] = self._get_nhosts(r)
                
                for k in this:
                    lens[k] = max(lens[k], len(('%s' % this[k])))
                
                lines.append(this)

        fmt = []
        for k in names:
            fmt.append('%('+k+')-'+str(lens[k])+'s')
        fmt = ' '.join(fmt)
        fmt = ' '+fmt


        # this is the header for each column
        if len(lines) > 0:
            print fmt % {'pid':'Pid','user':'User',
                         'status':'Status', 'priority':'Priority', 'ncores':'Ncores',
                         hname:hname.capitalize(),'command':'Command','time_sub':'t_in','time_run':'t_run'}
        for l in lines:
            print fmt % l

        njobs = nrun+nwait
        stats = 'Jobs: %s Running: %s Waiting: %s' % (njobs,nrun,nwait)
        if self.user is not None:
            print ' User: %s %s' % (','.join(self.user),stats)
        else:
            print ' %s' % stats
                
    def _get_ncores(self, r):
        if r['status'] == 'run':
            return len(r['hosts'])
        else:
            return '-'

    def _time_diff(self,dt):
        ## surprisingly enough, nothing like this in date or time modules
        ds = int (dt)
        nd = int(ds/(24*60*60))
        ds -= nd*24*60*60
        nh = int (ds/(3600))
        ds -= nh*3600
        nm = int (ds/60)
        ds -= nm*60
        ns = ds
        r=''
        if (nd>0):
            r+=str(nd)+'d'
        if (nh>0):
            r+=str(nh)+'h'
        if (nm>0):
            r+=str(nm)+'m'
        r+=str(ns)+'s'
        return r
                  


    def _get_time_in(self, r,timenow):
        return self._time_diff(timenow-r['time_sub'])

    def _get_time_run(self, r,timenow):
        if r['status'] == 'run':
            return self._time_diff(timenow-r['time_run'])
        else:
            return '-'


    def _get_hosts(self, r):
        if r['status'] != 'run':
            return '-'

        if not r['hosts']:
            return '-'
        else:
            hd={}
            for host in r['hosts']:
                hd[host] = host
            hosts = list(hd.keys())
            hosts.sort()
            return ','.join(hosts)

    def _get_nhosts(self, r):
        if r['status'] == 'run':
            hd={}
            for host in r['hosts']:
                hd[host] = host
            return len(hd)
        else:
            return '-'

    def _get_status(self, r):
        if self.full:
            if r['status'] == 'run':
                return 'running'
            else:
                return r['reason']
        else:
            if r['status'] == 'run':
                return 'R'
            else:
                return 'W'

    def _get_command(self, r):
        if self.full:
            return r['commandline']
        else:
            return r['commandline'].split()[0]

class Stats(dict):
    """
    usage: wq stat

    print the status of the queue and compute cluster
    """

    def __init__(self, args):
        parser=OptionParser(Stats.__doc__)
        options, args = parser.parse_args(args)

    def execute(self):
        message={}
        message['command'] = 'stat'

        resp = send_message(message)

        status=resp['response']

        wq.server.print_stat(status)

class Refresher(dict):
    """
    usage: wq refresh

    Request that the server refresh it's job list
    """

    def __init__(self, args):
        parser=OptionParser(Refresher.__doc__)
        options, args = parser.parse_args(args)

    def execute(self):
        message={}
        message['command'] = 'refresh'

        resp = send_message(message)

class Remover(dict):
    """
    usage: wq rm pid

    Request that the server remove the specified job.  Send 'all' for the pid
    to remove all of your jobs.
    """

    def __init__(self, args):
        parser=OptionParser(Remover.__doc__)
        parser.add_option("-a", "--all", action="store_true",
                          help="remove all jobs for current user")
        options, args = parser.parse_args(args)

        if options.all:
            self.pid='all'
        else:
            self.pid = int(args[0])

    def execute(self):
        message={}
        message['command'] = 'rm'
        message['pid'] = self.pid
        message['user'] = os.environ['USER']

        resp = send_message(message)

        if resp['response']=='OK':
            if 'pids_to_kill' not in resp:
                print "Internal error, server shuold return pids_to_kill."
                sys.exit(1)

            # this is always a list, for when we do "wq rm all"
            pids_to_kill = resp['pids_to_kill']
            for pidtokill in pids_to_kill:

                os.kill(pidtokill,signal.SIGTERM)
                time.sleep (0.1) ## sleep  a bit
                cc=0
                while (self._pid_exists(pidtokill) and (cc<100)): #see when it disappears, up to 10sec
                    time.sleep(0.1)
                    cc+=1
                if (self._pid_exists(pidtokill)):
                    #bastard wouldn't die
                    os.kill(pid,signal.SIGKILL)
                    time.sleep(1)

            ## Now refresh to remove it from queue
            message={}
            message['command'] = 'refresh'
            resp = send_message(message)

        else:
            print "Cannot remove, reason=", resp['error']

    def _pid_exists(self, pid):        
        """ Check For the existence of a unix pid. """
        try:
            # this doesn't actually kill the job, it does nothing if the pid
            # exists, if doesn't exist raises OSError
            os.kill(pid, 0)
        except OSError:
            return False
        else:
            return True



class Submitter(dict):
    """
    usage: wq sub [options] [args]

    two basic modes:
        1) 
            wq sub -r require job_file

        Where job_file is in YAML format and has a command and a set of
        requirements.  -r/--require will over-ride requirements in the job
        file.  the long form of -r is --require

        2)
            wq sub -r require -c command

        The command is just a string.  You probably want to double quote it.
    """
    def __init__(self, args):
        #Command.__init__(self, args)
        self._process_args(args)

    def _process_args(self, args):
        parser=OptionParser(Submitter.__doc__)
        parser.add_option("-r", "--require", default=None, help="optional requirements for job")
        parser.add_option("-c", "--command", default=None, help="The command to run as a string")

        options, args = parser.parse_args(args)

        self['require_arg'] = options.require
        if len(args) > 0:
            # a job file was sent
            job_file = args[0]
            self._process_job_file(job_file)
        else:
            if options.command is None:
                parser.print_help()
                sys.exit(1)
            command = options.command
            self._process_command_string(command)

    def _process_job_file(self, fname):
        import yaml

        self['require'] = yaml.load(open(fname))
        if 'command' not in self['require']:
            raise ValueError("no command found in job file")
        self['commandline'] = self['require']['command']

        # don't need this in the requirements
        del self['require']['command']
        

    def _process_command_string(self, command):
        """
        The command is determined by an argument.  Requirements are only
        specified by -r/--require now
        """
        require = self._process_require_arg()

        self['require'] = require
        self['commandline'] = command

    def _process_require_arg(self):
        import yaml
        import re

        req={}
        if self['require_arg'] is None:
            return req

        # convert semicolon to newline
        r = self['require_arg']
        r = re.sub(';\s*', '\n', r)
        # make sure there is a space between : and valule
        r = r.replace(':',': ')
        
        req = yaml.load(r)

        return req

    def print_job_info(self):
        print '------------'
        print 'Job info:\n'
        print 'command line:',self['commandline']
        for k in self['require']:
            print '%s: %s' % (k,self['require'][k])
        print '------------'

    def receive_signal(self,a,b):
        pass

    def receive_kill(self,a,b):
        try:
            self.remoteprocess.kill()
        except:
            pass

        self.message['command']='notify'
        self.message['notification']='done'
        #sres = send_message(self.message, timeout=SOCK_TIMEOUT, crash_on_timeout=True)
        sres = send_message(self.message)
        print sres
        exit(0)
                                        
    def make_command_list(self, target_machine, command, require):
        # first, force pseudo tty; this is key to make sure command
        # dies if this client dies
        cmdlist = ['ssh','-t', '-t']

        # should we forward X? default is no no.  This is in the
        # requirements as
        #   X: true or X: 1 for yes (anything evaluates as True in python)
        #   X: false or X: 0 for no
        xforward = require.get('X',False)
        if not xforward:
            cmdlist.append('-x')

        # full command, we first change directory to CWD
        pwd =os.getcwd()
        full_command='cd '+pwd+'; '+command

        cmdlist.append(target_machine)
        cmdlist.append(full_command)

        return cmdlist

    def execute(self):
        """

        - build the message request for the server.  
        - send the message and await reply
        - Maybe wait until we can run 
        - ssh into the target machine and run the job in the same
          directory where this client is running.

        For MPI jobs, a host file can be created.
        """
        message = {}
        message['command'] = 'sub'
        message['pid'] = os.getpid()
        message['user'] = os.environ['USER']
        message['require'] = self['require']
        message['commandline'] = self['commandline']

        sres = send_message(message)

        if sres['response'] == 'wait':
            # wait until we can go
            print "waiting:",sres['reason']
            #signal.signal(signal.SIGUSR1, self.receive_signal)
            fname = sres['spool_fname']
            wsleep = sres['spool_wait']
            while True:
                time.sleep(wsleep)
                try:
                    print "trying:",fname
                    open(fname)
                    print "ok"
                    break
                except IOError:
                    pass


            message['command']='gethosts'
            sres=send_message(message)

        ## save final message for potential kill
        self.message=message

        ## if hostfile specified need to create one
        hosts=sres['hosts']
        if 'hostfile' in self['require']:
            f=open(self['require']['hostfile'],'w')
            for h in hosts:
                f.write(h+'\n')
            f.close()

        target=hosts[0]
        command=self['commandline']

        ## here we execute
        print "executing on host: %s with pid: %s" % (target,message['pid'])
        signal.signal(signal.SIGTERM, self.receive_kill)

        cmdlist = self.make_command_list(target,command,self['require'])
        self.remoteprocess= subprocess.Popen(cmdlist)
        #self.remoteprocess= subprocess.Popen(['ssh','-t', '-t',target,'cd '+pwd+'; '+command])
        self.remoteprocess.wait()

        ### now we notify done.
        print "done"
        message['command']='notify'
        message['notification']='done'

        # we want to die if the notification fails so the server will see
        # the missing pid
        #sres = send_message(self.message, timeout=SOCK_TIMEOUT, crash_on_timeout=True)
        sres = send_message(self.message)
        print sres

def socket_connect(sock, conninfo, crash_on_timeout=False):
    # crash will only happen if timeouts have been enabled, otherwise we just
    # wait
    if crash_on_timeout:
        sock.connect(conninfo)
    else:
        while True:
            try:
                sock.connect(conninfo)
                break
            except socket.timeout:
                pass

def socket_send(sock, mess):
    """
    Need to do this with timeouts, which are non-blocking under the hood

    hmm... is this going to max the cpu if we can't get through right away?
    """
    reslen=len(mess)
    tnsent=conn.send(mess)
    nsent = tnsent
    if nsent < reslen:
        tnsent=conn.send(mess[nsent:])
        nsent += tnsent


def send_message(message, timeout=None, crash_on_timeout=False):
    if len(message) == 0:
        raise ValueError("message must have len > 0")

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # make sure to set timeout *before* calling connect()
    if timeout is not None:
        sock.settimeout(timeout)

    conninfo = (pars['host'], pars['port'])
    socket_connect(sock, conninfo, crash_on_timeout=crash_on_timeout)

    rdict=None
    try:
        jmess=json.dumps(message)

        wq.server.socket_send(sock, jmess)
        data = wq.server.socket_recieve(sock, pars['max_buffsize'])

        sock.close()

        try:
            rdict = json.loads(data)
        except:
            print 'json err:'
            print data
            sys.exit(1)

        if 'error' in rdict:
            raise RuntimeError("Error reported by server: %s" % rdict['error'])

        if 'response' not in rdict:
            raise RuntimeError("Internal error. Expected a response and got screwed.")

    except:
        es=sys.exc_info()
        print 'caught exception type:', es[0],'details:',es[1]
    finally:
        sock.close()

    if rdict is None:
        sys.exit(1)

    return rdict


def get_command_obj(args):
    if args[0] == 'sub':
        return Submitter(args[1:])
    elif args[0] == 'ls':
        return Lister(args[1:])
    elif args[0] == 'stat':
        return Stats(args[1:])
    elif args[0] == 'rm':
        return Remover(args[1:])
    elif args[0] == 'refresh':
        return Refresher(args[1:])
    elif args[0] == 'serve':
        return ServerWrapper(args[1:])
    else:
        return None

def main():

    parser=OptionParser(__doc__)
    # this won't be used in the usual way
    parser.add_option("-p", "--port", default=None, help="port for socket")

    args = sys.argv[1:]
    if len(args) == 0:
        parser.print_help()
        sys.exit(1)

    if args[0] == '-h':
        parser.print_help()
        sys.exit(1)

    if args[0] == '-p':
        del args[0]
        try:
            pars['port'] = int(args[0])
        except:
            print 'Could not extract port from input: %s' % args[1]
            sys.exit(1)
        del args[0]

    # now we can get the actual command, if it exists
    if len(args) == 0:
        parser.print_help()
        sys.exit(1)

    cmd_obj = get_command_obj(args)
    if cmd_obj is None:
        parser.print_help()
        sys.exit(1)

    try:
        cmd_obj.execute()
    except KeyboardInterrupt:
        pass

if __name__=="__main__":
    main()
